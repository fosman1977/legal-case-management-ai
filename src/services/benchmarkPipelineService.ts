/**
 * Automated Benchmark Testing Pipeline
 * Manages scheduled benchmarking, baseline establishment, and continuous improvement tracking
 */

import { legalBenchmarkService } from './legalBenchmarkService';
import { engineMonitoringService } from './engineMonitoringService';

interface BenchmarkSchedule {
  id: string;
  name: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  engines: string[];
  suites: ('legalbench' | 'lnat' | 'watson-glaser')[];
  enabled: boolean;
  lastRun: Date | null;
  nextRun: Date | null;
}

interface PerformanceBaseline {
  engineName: string;
  suite: string;
  baselineScore: number;
  establishedDate: Date;
  sampleSize: number;
  confidenceLevel: number;
  lastUpdated: Date;
}

interface ImprovementTracking {
  engineName: string;
  period: '7d' | '30d' | '90d';
  trend: 'improving' | 'stable' | 'declining';
  changePercent: number;
  significanceLevel: number;
  lastCalculated: Date;
  recommendations: string[];
}

interface BenchmarkAlert {
  id: string;
  type: 'performance_degradation' | 'baseline_deviation' | 'continuous_decline' | 'new_baseline_needed';
  engineName: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  currentValue: number;
  expectedValue: number;
  timestamp: Date;
  acknowledged: boolean;
  autoGenerated: boolean;
}

export class BenchmarkPipelineService {
  private schedules: Map<string, BenchmarkSchedule> = new Map();
  private baselines: Map<string, PerformanceBaseline[]> = new Map();
  private improvements: Map<string, ImprovementTracking[]> = new Map();
  private alerts: BenchmarkAlert[] = [];
  private isRunning = false;
  private pipelineInterval: NodeJS.Timeout | null = null;

  constructor() {
    this.initializeDefaultSchedules();
  }

  /**
   * Initialize default benchmark schedules
   */
  private initializeDefaultSchedules(): void {
    // Daily quick checks
    this.schedules.set('daily-quick', {
      id: 'daily-quick',
      name: 'Daily Quick Assessment',
      frequency: 'daily',
      engines: ['blackstone-uk', 'eyecite'],
      suites: ['legalbench'],
      enabled: true,
      lastRun: null,
      nextRun: this.calculateNextRun('daily')
    });

    // Weekly comprehensive assessment
    this.schedules.set('weekly-comprehensive', {
      id: 'weekly-comprehensive',
      name: 'Weekly Comprehensive Assessment',
      frequency: 'weekly',
      engines: [
        'blackstone-uk',
        'eyecite',
        'legal-regex',
        'spacy-legal',
        'custom-uk',
        'database-validator',
        'statistical-validator'
      ],
      suites: ['legalbench', 'lnat', 'watson-glaser'],
      enabled: true,
      lastRun: null,
      nextRun: this.calculateNextRun('weekly')
    });

    // Monthly baseline review
    this.schedules.set('monthly-baseline', {
      id: 'monthly-baseline',
      name: 'Monthly Baseline Review',
      frequency: 'monthly',
      engines: [
        'blackstone-uk',
        'eyecite',
        'legal-regex',
        'spacy-legal',
        'custom-uk',
        'database-validator',
        'statistical-validator'
      ],
      suites: ['legalbench', 'lnat', 'watson-glaser'],
      enabled: true,
      lastRun: null,
      nextRun: this.calculateNextRun('monthly')
    });
  }

  /**
   * Start automated benchmark pipeline
   */
  async start(): Promise<void> {
    if (this.isRunning) return;

    console.log('üöÄ Starting Automated Benchmark Pipeline...');
    
    this.isRunning = true;
    
    // Check for scheduled benchmarks every hour
    this.pipelineInterval = setInterval(() => {
      this.checkScheduledBenchmarks();
    }, 3600000); // 1 hour

    // Initial check
    await this.checkScheduledBenchmarks();

    console.log('‚úÖ Automated Benchmark Pipeline started');
  }

  /**
   * Stop automated pipeline
   */
  stop(): void {
    if (this.pipelineInterval) {
      clearInterval(this.pipelineInterval);
      this.pipelineInterval = null;
    }
    this.isRunning = false;
    console.log('‚èπÔ∏è Automated Benchmark Pipeline stopped');
  }

  /**
   * Check for and execute scheduled benchmarks
   */
  private async checkScheduledBenchmarks(): Promise<void> {
    const now = new Date();
    
    for (const schedule of this.schedules.values()) {
      if (schedule.enabled && schedule.nextRun && now >= schedule.nextRun) {
        await this.executeScheduledBenchmark(schedule);
      }
    }
  }

  /**
   * Execute a scheduled benchmark
   */
  private async executeScheduledBenchmark(schedule: BenchmarkSchedule): Promise<void> {
    console.log(`üìä Executing scheduled benchmark: ${schedule.name}`);
    
    try {
      // Run benchmarks for each engine and suite combination
      for (const engineName of schedule.engines) {
        for (const suite of schedule.suites) {
          console.log(`üß™ Testing ${engineName} on ${suite}...`);
          
          const performance = await legalBenchmarkService.runBenchmarkSuite(engineName, suite);
          
          // Update baselines if this is a baseline review
          if (schedule.id === 'monthly-baseline') {
            await this.updateBaseline(engineName, suite, performance);
          }
          
          // Check for performance issues
          await this.checkPerformanceAlerts(engineName, suite, performance);
        }
      }
      
      // Update schedule
      schedule.lastRun = new Date();
      schedule.nextRun = this.calculateNextRun(schedule.frequency, schedule.lastRun);
      
      // Update improvement tracking
      await this.updateImprovementTracking();
      
      console.log(`‚úÖ Completed scheduled benchmark: ${schedule.name}`);
      
    } catch (error) {
      console.error(`‚ùå Failed to execute scheduled benchmark ${schedule.name}:`, error);
      
      // Create alert for failed benchmark
      this.createAlert({
        type: 'performance_degradation',
        engineName: 'pipeline',
        severity: 'high',
        message: `Scheduled benchmark "${schedule.name}" failed to execute`,
        currentValue: 0,
        expectedValue: 1,
        autoGenerated: true
      });
    }
  }

  /**
   * Update performance baseline
   */
  private async updateBaseline(
    engineName: string, 
    suite: string, 
    performance: any
  ): Promise<void> {
    const key = `${engineName}-${suite}`;
    
    if (!this.baselines.has(engineName)) {
      this.baselines.set(engineName, []);
    }
    
    const engineBaselines = this.baselines.get(engineName)!;
    const existingBaseline = engineBaselines.find(b => b.suite === suite);
    
    const score = this.getScoreForSuite(performance, suite);
    
    if (existingBaseline) {
      // Update existing baseline using rolling average
      const weight = 0.2; // 20% weight for new data
      const newScore = existingBaseline.baselineScore * (1 - weight) + score * weight;
      
      existingBaseline.baselineScore = newScore;
      existingBaseline.lastUpdated = new Date();
      existingBaseline.sampleSize += 1;
      
      console.log(`üìä Updated baseline for ${engineName} ${suite}: ${newScore.toFixed(1)}%`);
    } else {
      // Create new baseline
      const newBaseline: PerformanceBaseline = {
        engineName,
        suite,
        baselineScore: score,
        establishedDate: new Date(),
        sampleSize: 1,
        confidenceLevel: 0.85, // Start with moderate confidence
        lastUpdated: new Date()
      };
      
      engineBaselines.push(newBaseline);
      
      console.log(`üéØ Established new baseline for ${engineName} ${suite}: ${score}%`);
    }
  }

  /**
   * Check for performance alerts
   */
  private async checkPerformanceAlerts(
    engineName: string,
    suite: string,
    performance: any
  ): Promise<void> {
    const engineBaselines = this.baselines.get(engineName) || [];
    const baseline = engineBaselines.find(b => b.suite === suite);
    
    if (!baseline) return; // No baseline established yet
    
    const currentScore = this.getScoreForSuite(performance, suite);
    const deviation = baseline.baselineScore - currentScore;
    const deviationPercent = (deviation / baseline.baselineScore) * 100;
    
    // Check for significant degradation
    if (deviationPercent > 10) {
      this.createAlert({
        type: 'performance_degradation',
        engineName,
        severity: deviationPercent > 20 ? 'critical' : 'high',
        message: `${suite} performance dropped ${deviationPercent.toFixed(1)}% below baseline`,
        currentValue: currentScore,
        expectedValue: baseline.baselineScore,
        autoGenerated: true
      });
    } else if (deviationPercent > 5) {
      this.createAlert({
        type: 'baseline_deviation',
        engineName,
        severity: 'medium',
        message: `${suite} performance ${deviationPercent.toFixed(1)}% below baseline`,
        currentValue: currentScore,
        expectedValue: baseline.baselineScore,
        autoGenerated: true
      });
    }
  }

  /**
   * Update improvement tracking
   */
  private async updateImprovementTracking(): Promise<void> {
    const performances = legalBenchmarkService.getAllPerformances();
    
    for (const performance of performances) {
      if (!this.improvements.has(performance.engineName)) {
        this.improvements.set(performance.engineName, []);
      }
      
      const improvements = this.improvements.get(performance.engineName)!;
      
      // Calculate trends for different periods
      const periods: ('7d' | '30d' | '90d')[] = ['7d', '30d', '90d'];
      
      for (const period of periods) {
        const trend = this.calculateTrend(performance.engineName, period);
        
        const existingImprovement = improvements.find(i => i.period === period);
        
        if (existingImprovement) {
          existingImprovement.trend = trend.trend;
          existingImprovement.changePercent = trend.changePercent;
          existingImprovement.significanceLevel = trend.significanceLevel;
          existingImprovement.lastCalculated = new Date();
          existingImprovement.recommendations = this.generateImprovementRecommendations(trend);
        } else {
          improvements.push({
            engineName: performance.engineName,
            period,
            trend: trend.trend,
            changePercent: trend.changePercent,
            significanceLevel: trend.significanceLevel,
            lastCalculated: new Date(),
            recommendations: this.generateImprovementRecommendations(trend)
          });
        }
      }
    }
  }

  /**
   * Calculate performance trend
   */
  private calculateTrend(engineName: string, period: '7d' | '30d' | '90d'): {
    trend: 'improving' | 'stable' | 'declining';
    changePercent: number;
    significanceLevel: number;
  } {
    // Simulate trend calculation (in production, would analyze historical data)
    const baseChange = (Math.random() - 0.5) * 10; // -5% to +5%
    const noise = (Math.random() - 0.5) * 2; // Add some noise
    const changePercent = baseChange + noise;
    
    let trend: 'improving' | 'stable' | 'declining' = 'stable';
    if (changePercent > 2) trend = 'improving';
    else if (changePercent < -2) trend = 'declining';
    
    const significanceLevel = Math.min(0.95, 0.5 + Math.abs(changePercent) * 0.1);
    
    return {
      trend,
      changePercent: Math.round(changePercent * 10) / 10,
      significanceLevel: Math.round(significanceLevel * 100) / 100
    };
  }

  /**
   * Generate improvement recommendations
   */
  private generateImprovementRecommendations(trend: {
    trend: 'improving' | 'stable' | 'declining';
    changePercent: number;
  }): string[] {
    const recommendations: string[] = [];
    
    if (trend.trend === 'declining') {
      recommendations.push('Consider retraining with recent legal documents');
      recommendations.push('Review engine configuration for optimization opportunities');
      recommendations.push('Analyze failed test cases for pattern identification');
    } else if (trend.trend === 'improving') {
      recommendations.push('Document successful changes for replication');
      recommendations.push('Consider expanding to additional use cases');
      recommendations.push('Share improvements with similar engines');
    } else {
      recommendations.push('Maintain current configuration');
      recommendations.push('Monitor for emerging improvement opportunities');
    }
    
    return recommendations;
  }

  /**
   * Create benchmark alert
   */
  private createAlert(alertData: Omit<BenchmarkAlert, 'id' | 'timestamp' | 'acknowledged'>): void {
    const alert: BenchmarkAlert = {
      ...alertData,
      id: `benchmark_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
      timestamp: new Date(),
      acknowledged: false
    };
    
    this.alerts.push(alert);
    
    // Log alert
    const severityIcons = {
      low: 'üü°',
      medium: 'üü†',
      high: 'üî¥',
      critical: 'üö®'
    };
    
    console.log(`${severityIcons[alert.severity]} BENCHMARK ALERT: ${alert.engineName} - ${alert.message}`);
  }

  /**
   * Utility methods
   */
  private calculateNextRun(frequency: 'daily' | 'weekly' | 'monthly', from: Date = new Date()): Date {
    const next = new Date(from);
    
    switch (frequency) {
      case 'daily':
        next.setDate(next.getDate() + 1);
        next.setHours(2, 0, 0, 0); // 2 AM
        break;
      case 'weekly':
        next.setDate(next.getDate() + 7);
        next.setHours(1, 0, 0, 0); // 1 AM Sunday
        break;
      case 'monthly':
        next.setMonth(next.getMonth() + 1);
        next.setDate(1);
        next.setHours(0, 30, 0, 0); // 12:30 AM first of month
        break;
    }
    
    return next;
  }

  private getScoreForSuite(performance: any, suite: string): number {
    switch (suite) {
      case 'legalbench':
        return performance.legalBenchScore || 0;
      case 'lnat':
        return performance.lnatScore || 0;
      case 'watson-glaser':
        return performance.watsonGlaserScore || 0;
      default:
        return performance.overallScore || 0;
    }
  }

  /**
   * Public API methods
   */
  
  getSchedules(): BenchmarkSchedule[] {
    return Array.from(this.schedules.values());
  }

  getBaselines(engineName?: string): PerformanceBaseline[] {
    if (engineName) {
      return this.baselines.get(engineName) || [];
    }
    return Array.from(this.baselines.values()).flat();
  }

  getImprovements(engineName?: string): ImprovementTracking[] {
    if (engineName) {
      return this.improvements.get(engineName) || [];
    }
    return Array.from(this.improvements.values()).flat();
  }

  getBenchmarkAlerts(): BenchmarkAlert[] {
    return this.alerts.filter(a => !a.acknowledged);
  }

  acknowledgeAlert(alertId: string): boolean {
    const alert = this.alerts.find(a => a.id === alertId);
    if (alert) {
      alert.acknowledged = true;
      return true;
    }
    return false;
  }

  async runManualBenchmark(engineName: string, suite: 'legalbench' | 'lnat' | 'watson-glaser'): Promise<any> {
    console.log(`üß™ Running manual benchmark: ${engineName} on ${suite}`);
    
    const performance = await legalBenchmarkService.runBenchmarkSuite(engineName, suite);
    
    // Check for alerts
    await this.checkPerformanceAlerts(engineName, suite, performance);
    
    return performance;
  }

  getPipelineStatus(): {
    isRunning: boolean;
    activeSchedules: number;
    nextScheduledRun: Date | null;
    totalBaselines: number;
    pendingAlerts: number;
  } {
    const enabledSchedules = Array.from(this.schedules.values()).filter(s => s.enabled);
    const nextRuns = enabledSchedules
      .map(s => s.nextRun)
      .filter(Boolean) as Date[];
    
    return {
      isRunning: this.isRunning,
      activeSchedules: enabledSchedules.length,
      nextScheduledRun: nextRuns.length > 0 ? new Date(Math.min(...nextRuns.map(d => d.getTime()))) : null,
      totalBaselines: Array.from(this.baselines.values()).flat().length,
      pendingAlerts: this.alerts.filter(a => !a.acknowledged).length
    };
  }

  async establishBaseline(engineName: string, suite: string, iterations: number = 5): Promise<PerformanceBaseline> {
    console.log(`üìä Establishing baseline for ${engineName} ${suite} (${iterations} iterations)...`);
    
    const scores: number[] = [];
    
    for (let i = 0; i < iterations; i++) {
      const performance = await legalBenchmarkService.runBenchmarkSuite(engineName, suite as any);
      scores.push(this.getScoreForSuite(performance, suite));
    }
    
    // Calculate baseline statistics
    const averageScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - averageScore, 2), 0) / scores.length;
    const stdDev = Math.sqrt(variance);
    const confidenceLevel = Math.max(0.5, Math.min(0.95, 0.8 - (stdDev / averageScore) * 0.5));
    
    const baseline: PerformanceBaseline = {
      engineName,
      suite,
      baselineScore: Math.round(averageScore * 10) / 10,
      establishedDate: new Date(),
      sampleSize: iterations,
      confidenceLevel: Math.round(confidenceLevel * 100) / 100,
      lastUpdated: new Date()
    };
    
    // Store baseline
    if (!this.baselines.has(engineName)) {
      this.baselines.set(engineName, []);
    }
    
    const engineBaselines = this.baselines.get(engineName)!;
    const existingIndex = engineBaselines.findIndex(b => b.suite === suite);
    
    if (existingIndex >= 0) {
      engineBaselines[existingIndex] = baseline;
    } else {
      engineBaselines.push(baseline);
    }
    
    console.log(`‚úÖ Baseline established: ${averageScore.toFixed(1)}% ¬± ${stdDev.toFixed(1)}% (${confidenceLevel.toFixed(0)}% confidence)`);
    
    return baseline;
  }
}

// Export singleton instance
export const benchmarkPipelineService = new BenchmarkPipelineService();
export default benchmarkPipelineService;